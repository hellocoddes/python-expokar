# -*- coding: utf-8 -*-
"""7

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JJPI5_VtxqMlRqu9eXHSwu_Gepa6YZyY
"""

import numpy as np
import matplotlib.pyplot as plt
from itertools import product

class McCullochPittsNeuron:
    """
    Implementation of McCulloch-Pitts neuron model for basic logic gates.

    The McCulloch-Pitts neuron:
    - Takes binary inputs (0 or 1)
    - Has weighted connections
    - Has a threshold
    - Outputs 1 if weighted sum >= threshold, else 0
    """
    def __init__(self, weights, threshold):
        """
        Initialize the McCulloch-Pitts neuron.

        Parameters:
        - weights: List of weights for each input
        - threshold: Activation threshold
        """
        self.weights = np.array(weights)
        self.threshold = threshold

    def activate(self, inputs):
        """
        Activate the neuron with given inputs.

        Parameters:
        - inputs: List of binary inputs (0 or 1)

        Returns:
        - 1 if weighted sum >= threshold, else 0
        """
        # Convert inputs to numpy array if needed
        inputs = np.array(inputs)

        # Calculate weighted sum
        weighted_sum = np.dot(inputs, self.weights)

        # Apply threshold
        return 1 if weighted_sum >= self.threshold else 0

    def evaluate_logic_table(self, num_inputs):
        """
        Generate and evaluate all possible input combinations.

        Parameters:
        - num_inputs: Number of input bits

        Returns:
        - inputs_list: List of all possible input combinations
        - outputs: Corresponding outputs for each input combination
        """
        # Generate all possible input combinations (truth table)
        inputs_list = list(product([0, 1], repeat=num_inputs))

        # Evaluate each input combination
        outputs = [self.activate(inputs) for inputs in inputs_list]

        return inputs_list, outputs

    def print_truth_table(self, num_inputs):
        """
        Print the truth table for the logic gate.

        Parameters:
        - num_inputs: Number of input bits
        """
        inputs_list, outputs = self.evaluate_logic_table(num_inputs)

        # Print header
        input_headers = [f"Input {i+1}" for i in range(num_inputs)]
        print(f"{' | '.join(input_headers)} | Output")
        print("-" * (len(" | ".join(input_headers)) + 10))

        # Print rows
        for inputs, output in zip(inputs_list, outputs):
            inputs_str = " | ".join(str(i) for i in inputs)
            print(f"{inputs_str} | {output}")

    def plot_decision_boundary(self, num_inputs=2):
        """
        Plot the decision boundary for 2-input gates.
        Only works for 2 input neurons.

        Parameters:
        - num_inputs: Number of input bits (should be 2)
        """
        if num_inputs != 2:
            print("Decision boundary plotting only works for 2-input gates")
            return

        inputs_list, outputs = self.evaluate_logic_table(num_inputs)

        # Separate the points into two classes
        class_0 = np.array([inp for inp, out in zip(inputs_list, outputs) if out == 0])
        class_1 = np.array([inp for inp, out in zip(inputs_list, outputs) if out == 1])

        plt.figure(figsize=(8, 6))

        # Plot points
        if len(class_0) > 0:
            plt.scatter(class_0[:, 0], class_0[:, 1], c='red', marker='o', s=100, label='0')
        if len(class_1) > 0:
            plt.scatter(class_1[:, 0], class_1[:, 1], c='blue', marker='o', s=100, label='1')

        # Draw decision boundary if weights are not zero
        if self.weights[0] != 0 or self.weights[1] != 0:
            if self.weights[1] != 0:
                x = np.linspace(-0.5, 1.5, 100)
                # Equation: w1*x1 + w2*x2 = threshold
                # So x2 = (threshold - w1*x1) / w2
                y = (self.threshold - self.weights[0] * x) / self.weights[1]
                plt.plot(x, y, 'g-', label='Decision Boundary')
            else:
                # Vertical line if w2 = 0
                plt.axvline(x=self.threshold/self.weights[0], color='g', label='Decision Boundary')

        plt.grid(True)
        plt.xlabel('Input 1')
        plt.ylabel('Input 2')
        plt.title(f'McCulloch-Pitts Neuron Decision Boundary\nWeights={self.weights}, Threshold={self.threshold}')
        plt.xlim(-0.5, 1.5)
        plt.ylim(-0.5, 1.5)
        plt.legend()
        plt.show()

# Function to implement different logic gates
def create_logic_gate(gate_type):
    """
    Create a McCulloch-Pitts neuron implementing a specific logic gate.

    Parameters:
    - gate_type: String specifying the logic gate ('AND', 'OR', 'NOT', 'NAND', 'NOR', 'XOR')

    Returns:
    - McCullochPittsNeuron object configured for the specified gate
    """
    if gate_type == 'AND':
        # AND gate: both inputs must be 1
        # w1 = 1, w2 = 1, threshold = 2
        return McCullochPittsNeuron([1, 1], 2)

    elif gate_type == 'OR':
        # OR gate: at least one input must be 1
        # w1 = 1, w2 = 1, threshold = 1
        return McCullochPittsNeuron([1, 1], 1)

    elif gate_type == 'NOT':
        # NOT gate: inverts the input
        # w1 = -1, threshold = 0
        # Note: McCulloch-Pitts model traditionally uses inhibitory inputs
        return McCullochPittsNeuron([-1], 0)

    elif gate_type == 'NAND':
        # NAND gate: NOT of AND gate
        # w1 = -1, w2 = -1, threshold = -1
        return McCullochPittsNeuron([-1, -1], -1)

    elif gate_type == 'NOR':
        # NOR gate: NOT of OR gate
        # w1 = -1, w2 = -1, threshold = 0
        return McCullochPittsNeuron([-1, -1], 0)

    elif gate_type == 'XOR':
        # XOR gate: inputs must be different
        # Note: XOR cannot be implemented with a single McCulloch-Pitts neuron!
        print("XOR cannot be implemented with a single McCulloch-Pitts neuron.")
        print("It requires multiple neurons or a multi-layer network.")
        return None

    else:
        print(f"Unknown gate type: {gate_type}")
        return None

# Demo function to show all logic gates
def demo_all_gates():
    """
    Demonstrate all implemented logic gates with truth tables and decision boundaries.
    """
    # Gates that work with 2 inputs
    two_input_gates = ['AND', 'OR', 'NAND', 'NOR', 'XOR']

    for gate_type in two_input_gates:
        print(f"\n{'-'*40}")
        print(f"Logic Gate: {gate_type}")
        print(f"{'-'*40}")

        neuron = create_logic_gate(gate_type)
        if neuron:
            print(f"Weights: {neuron.weights}, Threshold: {neuron.threshold}")
            print("\nTruth Table:")
            neuron.print_truth_table(2)

            # Plot decision boundary
            neuron.plot_decision_boundary()

    # NOT gate (1 input)
    print(f"\n{'-'*40}")
    print(f"Logic Gate: NOT")
    print(f"{'-'*40}")

    not_gate = create_logic_gate('NOT')
    print(f"Weights: {not_gate.weights}, Threshold: {not_gate.threshold}")
    print("\nTruth Table:")
    not_gate.print_truth_table(1)

# Example dataset to test the gates
def test_with_dataset():
    """
    Test the McCulloch-Pitts neurons with example dataset.
    """
    print("\nTesting with example dataset:")

    # Example dataset for 2-input logic gates
    dataset = [
        {'inputs': [0, 0], 'label': 'Example 1'},
        {'inputs': [0, 1], 'label': 'Example 2'},
        {'inputs': [1, 0], 'label': 'Example 3'},
        {'inputs': [1, 1], 'label': 'Example 4'}
    ]

    gates = ['AND', 'OR', 'NAND', 'NOR']

    # Test each gate with the dataset
    for gate_type in gates:
        print(f"\nTesting {gate_type} gate:")
        neuron = create_logic_gate(gate_type)

        for example in dataset:
            inputs = example['inputs']
            output = neuron.activate(inputs)
            print(f"{example['label']}: Inputs {inputs} -> Output {output}")

# Run the demo
print("McCulloch-Pitts Neuron Model: Logic Gates Implementation")
demo_all_gates()
test_with_dataset()

# Additional example: custom threshold logic
print("\nCustom Threshold Logic Example:")
# Implement a "Majority Gate" (outputs 1 if majority of inputs are 1)
majority_gate = McCullochPittsNeuron([1, 1, 1], 2)
print("Majority Gate (3 inputs, threshold = 2):")
majority_gate.print_truth_table(3)

# Implement a custom weighted gate
print("\nCustom Weighted Gate Example:")
weighted_gate = McCullochPittsNeuron([2, 1], 2)
print("Custom Gate (weights = [2, 1], threshold = 2):")
print("This gate will output 1 if first input is 1, or if both inputs are 1")
weighted_gate.print_truth_table(2)
weighted_gate.plot_decision_boundary()

